from __future__ import annotations

import asyncio
import logging
from typing import Any, Literal, Optional, Sequence, Tuple, Union

from pysnmp.hlapi.v3arch.asyncio import (
    CommunityData,
    ContextData,
    NotificationType,
    ObjectIdentity,
    ObjectType,
    SnmpEngine,
    UdpTransportTarget,
    send_notification,
)

OidIndex = Union[int, str, Tuple[int, ...]]
VarBindSpec = Union[
    ObjectType,
    Tuple[str, str, Any],              # (mib, symbol, value) for scalars
    Tuple[str, str, Any, OidIndex],    # (mib, symbol, value, index) for table columns
]


class TrapSender:
    """Encapsulates SNMP notification sending using PySNMP.

    This sender targets MIB-defined NOTIFICATION-TYPEs via NotificationType.
    Mandatory SNMPv2 varbinds (sysUpTime.0, snmpTrapOID.0) are automatically
    generated by PySNMP's NotificationType.

    If snmp_engine is provided (e.g., from the agent), it will be used directly,
    allowing traps to use the agent's actual uptime. Otherwise, a new engine is created.
    """

    def __init__(
        self,
        dest: Tuple[str, int] = ("localhost", 162),
        community: str = "public",
        logger: Optional[logging.Logger] = None,
        snmp_engine: Optional[Any] = None,
    ) -> None:
        self.snmp_engine = snmp_engine if snmp_engine is not None else SnmpEngine()
        self.dest = dest
        self.community = community
        self.logger = logger or logging.getLogger(__name__)

    @staticmethod
    def _coerce_varbind(spec: VarBindSpec) -> ObjectType:
        if isinstance(spec, ObjectType):
            return spec

        if not isinstance(spec, tuple):
            raise TypeError(
                "extra_varbinds entries must be ObjectType or tuple, got "
                f"{type(spec).__name__}: {spec!r}"
            )

        mib, symbol, value, *rest = spec

        if not rest:
            # Scalar: symbol.0
            return ObjectType(ObjectIdentity(mib, symbol, 0), value)

        if len(rest) == 1:
            index = rest[0]
            if isinstance(index, tuple):
                return ObjectType(ObjectIdentity(mib, symbol, *index), value)
            return ObjectType(ObjectIdentity(mib, symbol, index), value)

        raise ValueError(
            "Unsupported varbind tuple. Expected (mib, symbol, value) or "
            f"(mib, symbol, value, index). Got: {spec!r}"
        )

    async def send_mib_notification_async(
        self,
        mib: str,
        notification: str,
        trap_type: Literal["trap", "inform"] = "inform",
        extra_varbinds: Optional[Sequence[VarBindSpec]] = None,
    ) -> None:
        # When using the agent's SnmpEngine, sysUpTime is already correct via the readGet wrapper
        # No need to manually set it - NotificationType will read from the engine's MIB
        notif = NotificationType(ObjectIdentity(mib, notification))

        if extra_varbinds:
            coerced = [self._coerce_varbind(vb) for vb in extra_varbinds]
            notif = notif.add_var_binds(*coerced)

        error_indication, error_status, error_index, _ = await send_notification(
            self.snmp_engine,
            CommunityData(self.community),
            await UdpTransportTarget.create(self.dest),
            ContextData(),
            trap_type,
            notif,
        )

        if error_indication:
            self.logger.error("Notification send error: %s", error_indication)
            return

        if error_status:
            self.logger.error(
                "Notification send error: %s at %s",
                error_status,
                error_index,
            )
            return

        self.logger.info(
            "Notification sent to %s:%s %s::%s",
            self.dest[0],
            self.dest[1],
            mib,
            notification,
        )

    def send_mib_notification(
        self,
        mib: str,
        notification: str,
        trap_type: Literal["trap", "inform"] = "inform",
        extra_varbinds: Optional[Sequence[VarBindSpec]] = None,
    ) -> None:
        """
        Synchronous wrapper.

        If called from within a running event loop, this schedules the send and returns.
        """
        try:
            loop = asyncio.get_running_loop()
        except RuntimeError:
            asyncio.run(
                self.send_mib_notification_async(
                    mib=mib,
                    notification=notification,
                    trap_type=trap_type,
                    extra_varbinds=extra_varbinds,
                )
            )
            return

        loop.create_task(
            self.send_mib_notification_async(
                mib=mib,
                notification=notification,
                trap_type=trap_type,
                extra_varbinds=extra_varbinds,
            )
        )